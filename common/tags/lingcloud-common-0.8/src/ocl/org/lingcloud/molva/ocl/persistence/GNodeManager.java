/*
 *  @(#)GNodeManager.java  2007-8-6
 *
 *  Copyright (C) 2008-2011,
 *  LingCloud Team,
 *  Institute of Computing Technology,
 *  Chinese Academy of Sciences.
 *  P.O.Box 2704, 100190, Beijing, China.
 *
 *  http://lingcloud.org
 *  
 */

package org.lingcloud.molva.ocl.persistence;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.lingcloud.molva.ocl.util.DBConnUtil;
import org.lingcloud.molva.ocl.util.GNodeHbUtil;
import org.lingcloud.molva.ocl.util.GNodeUtil;
import org.lingcloud.molva.ocl.util.HashFunction;
import org.lingcloud.molva.ocl.util.ParaChecker;
import org.lingcloud.molva.ocl.util.StringUtil;

/**
 * <strong>Purpose:</strong><br>
 * To manage GNode store and lookup.
 * 
 * @version 1.0.1 2007-8-6<br>
 * @author zouyongqiang<br>
 * 
 */
public class GNodeManager {
	/**
	 * the log object.
	 */
	private static Log log = LogFactory.getLog(GNodeManager.class);

	/**
	 * To get the GNode object with the guid.
	 * 
	 * @param guid
	 *            the guid to be located.
	 * @return the GNode with the input guid. If not found, return null.
	 * @throws Exception
	 *             has exceptions.
	 */
	public GNode locate(String guid) throws Exception {
		long begin = System.currentTimeMillis();
		try {
			ID.getIDfromHexString(guid);
		} catch (Exception e) {
			String msg = "Not a valid ID string. " + e;
			log.error(msg);
			throw new Exception(msg);
		}

		Session session = null;
		Transaction tx = null;
		try {
			session = GNodeHbUtil.newInstance().getSessionFactory()
					.openSession();
			tx = session.beginTransaction();

			GNode info = (GNode) session.get(GNode.class, guid);

			// FIXME
			if (info != null) {
				info.setObj(DBConnUtil.undoEscape(info.getObj()));
			}

			tx.commit();

			long end = System.currentTimeMillis();
			log.info("locate " + guid + " " + info + " time " + (end - begin));
			return info;
		} catch (Exception e) {
			log.error("transaction failed! " + e);
			try {
				log.warn("Trying to rollback transaction after exception");
				tx.rollback();
			} catch (Throwable rbEx) {
				log.error("Could not rollback transaction!", rbEx);
			}
			throw e;
		} finally {
			if (session != null) {
				session.close();
			}

		}
	}

	/**
	 * Register a GNode. Once registed, the GNode could be lookup and search
	 * globally.
	 * 
	 * @param gnode
	 *            the GNode including some fields, the naming system will fill
	 *            these system maintained fileds. You can set a guid, or let it
	 *            generated by system.
	 * @return a full GNode with all fields value setted.
	 * @throws Exception
	 *             the GNode with the same guid has existed, or other
	 *             exceptions.
	 */
	public GNode register(GNode gnode) throws Exception {
		long begin = System.currentTimeMillis();
		if (gnode == null) {
			String msg = "the input gnode is null.";
			log.error(msg);
			throw new Exception(msg);
		}
		GNodeUtil.checkGNodeAttr(gnode);

		ID idObj = null;
		try {
			idObj = ID.getIDfromHexString(gnode.getGuid());
		} catch (Exception e) {
			String msg = "Not a valid ID string. " + e
					+ "  Generate a new one.";
			log.info(msg);
			idObj = HashFunction.createGUID();
		}
		// Force gnode to a GNode object, so that even gnode is a subclass of
		// GNode, we can use it in hibernate without define the mapping of the
		// subclass. 2007.9.2
		GNode forcegn = gnode.toGNode();

		GNode gn = (GNode) forcegn.clone();
		String id = idObj.toString();
		gn.setGuid(id);

		// Set the origin id as the same one.
		// Bug fixed! gn.getOriginGNodeID may be is an empty string. eg : in C++
		// API, there is a serialize problem for string.
		if (StringUtil.isEmpty(gn.getOriginGNodeID())) {
			gn.setOriginGNodeID(id);
		}

		ParaChecker.checkAclFormat(gn.getAcl());

		GNode tmpGNode = null;
		try {
			tmpGNode = locate(id);
		} catch (Exception e) {
			String msg = "try to locate GNode failed. guid is : " + id
					+ " Reason : " + e;
			log.error(msg);
			throw new Exception(msg);
		}

		if (tmpGNode != null) {
			String msg = "GNode existed! name is : " + tmpGNode.getName()
					+ " guid is : " + id;
			log.error(msg);
			throw new Exception(msg);
		}

		GNode rst = localRegister(gn, true);
		long end = System.currentTimeMillis();
		log.info("register origin " + rst.getGuid() + " time " + (end - begin));
		return rst;
	}

	/**
	 * add the GNode to local site.
	 * 
	 * @param gnode
	 *            the GNode to be add.
	 * @param isActive
	 *            is local site actively execute this operation or passively add
	 *            this from a remote event?
	 * @return new GNode.
	 * @throws Exception
	 *             all kinds of exception.
	 */
	public GNode localRegister(GNode gnode, boolean isActive) throws Exception {
		Session session = null;
		Transaction tx = null;
		try {
			session = GNodeHbUtil.newInstance().getSessionFactory()
					.openSession();
			tx = session.beginTransaction();

			GNode tmpInfo = (GNode) session.get(GNode.class, gnode.getGuid());
			if (tmpInfo != null) {
				String msg = "GNode existed! name is : " + gnode.getName()
						+ " guid is : " + gnode.getGuid();
				log.error(msg);
				throw new Exception(msg);
			}

			// FIXME all should be escape.
			gnode.setObj(DBConnUtil.doEscape(gnode.getObj()));

			if (isActive) {
				String userID = null;
				String agoraID = null;

				gnode.setInitUserID(userID);
				gnode.setInitAgoraID(agoraID);

				// set property.
				gnode.setAddTime(new Date());
				gnode.setUpdateTime(new Date());
				gnode.setVersion(1);

			}
			// an real GNode.
			if (!gnode.isLink()) {
				session.save(gnode.getOriginGNodeInfo());
			}

			session.save(gnode);

			tx.commit();

			return gnode;
		} catch (Exception e) {
			log.error("transaction failed! " + e);
			try {
				log.warn("Trying to rollback transaction after exception");
				tx.rollback();
			} catch (Throwable rbEx) {
				log.error("Could not rollback transaction!", rbEx);
			}
			throw e;
		} finally {
			session.close();
		}
	}

	/**
	 * update the gnode in local site.
	 * 
	 * @param gnode
	 *            the new GNode object.
	 * @param isActive
	 *            is local site actively execute this operation or passively add
	 *            this from a remote event?
	 * @return the updated new GNode object.
	 * @throws Exception
	 *             all kinds of exception.
	 */
	private GNode localUpdate(GNode gnode, boolean isActive) throws Exception {
		GNode gn = (GNode) gnode.clone();

		GNode orignGNode = locate(gnode.getGuid());
		if (orignGNode == null) {
			String msg = "No such GNode with guid is " + gnode.getGuid();
			log.error(msg);
			throw new Exception(msg);
		}

		// To avoid update it to older version.
		if (!isActive && orignGNode.getVersion() > gn.getVersion()) {
			return orignGNode;
		}

		// FIXME
		if (gnode != null) {
			gnode.setObj(DBConnUtil.doEscape(gnode.getObj()));
		}

		if (isActive) {
			// must not modified.
			gn.setOriginGNodeID(orignGNode.getOriginGNodeID());
			gn.setHomeSiteID(orignGNode.getHomeSiteID());
			gn.setInitAgoraID(orignGNode.getInitAgoraID());
			gn.setInitUserID(orignGNode.getInitUserID());
			// TODO others ...

			// change this
			gn.setVersion(orignGNode.getVersion() + 1);

			gn.setUpdateTime(new Date());
		}

		Session session = null;
		Transaction tx = null;
		try {
			session = GNodeHbUtil.newInstance().getSessionFactory()
					.openSession();
			tx = session.beginTransaction();

			// don't allow to update the GNodeInfo unless it's origin GNode.
			if (!gn.isLink()) {
				session.update(gn.getOriginGNodeInfo());
			}
			session.update(gn);

			tx.commit();

			return gn;
		} catch (Exception e) {
			log.error("transaction failed! " + e);
			try {
				log.warn("Trying to rollback transaction after exception");
				tx.rollback();
			} catch (Throwable rbEx) {
				log.error("Could not rollback transaction!", rbEx);
			}
			throw e;
		} finally {
			session.close();
		}
	}

	/**
	 * Update the sepecified GNode.
	 * 
	 * @param gnode
	 *            The new GNode value. You must set the guid, and the GNode will
	 *            be set values accorrding to the input gnode.
	 * @return the updated GNode.
	 * @throws Exception
	 *             the GNode not existed. Or other exceptions.
	 */
	public GNode update(GNode gnode) throws Exception {
		long begin = System.currentTimeMillis();
		if (gnode == null) {
			String msg = "the input gnode is null.";
			log.error(msg);
			throw new Exception(msg);
		}

		GNodeUtil.checkGNodeAttr(gnode);

		// ID idObj = null;
		try {
			// idObj =
			ID.getIDfromHexString(gnode.getGuid());
		} catch (Exception e) {
			String msg = "Not a valid ID string. " + e;
			log.info(msg);
			throw new Exception(msg);
		}

		// Force gnode to a GNode object, so that even gnode is a subclass of
		// GNode, we can use it in hibernate without define the mapping of the
		// subclass. 2007.9.2
		GNode forcegn = gnode.toGNode();

		ParaChecker.checkAclFormat(forcegn.getAcl());

		GNode orignGNode = locate(forcegn.getGuid());
		if (orignGNode == null) {
			String msg = "No such GNode with guid is " + forcegn.getGuid();
			log.error(msg);
			throw new Exception(msg);
		}

		GNode result = localUpdate(forcegn, true);

		long end = System.currentTimeMillis();
		log.info("update local " + result.getGuid() + " time " + (end - begin));
		return result;
	}

	/**
	 * Unregister the GNode.
	 * 
	 * @param guid
	 *            the guid of the GNode to be unregistered.
	 * @return all deleted GNode object.
	 * @throws Exception
	 *             All kinds of exceptions.
	 */
	public List unregister(String guid) throws Exception {
		long begin = System.currentTimeMillis();
		try {
			ID.getIDfromHexString(guid);
		} catch (Exception e) {
			String msg = "Not a valid ID string. " + e;
			log.error(msg);
			throw new Exception(msg);
		}

		GNode gn = locate(guid);
		if (gn == null) {
			return new ArrayList();
		}

		
		List removed = localUnregister(guid, true);

		long end = System.currentTimeMillis();
		log.info("unregister local " + guid + " count " + removed.size()
				+ " time " + (end - begin));
		return removed;
	}

	/**
	 * unregister the GNode from local site. If it's origin GNode, then all the
	 * Link GNode of it will be removed at the same time.
	 * 
	 * @param guid
	 *            the guid of the GNode to be delete.
	 * @param isActive
	 *            is local site actively execute this operation or passively add
	 *            this from a remote event?
	 * @return all removed GNode. The origin GNode is the last element of the
	 *         List. We must return this, so that the users can add these GNode
	 *         back to naming if some operation failed and want to rollback.
	 * @throws Exception
	 *             all kinds of exception.
	 */
	private List localUnregister(String guid, boolean isActive)
			throws Exception {
		GNode gn = locate(guid);
		List removed = new ArrayList();
		if (gn == null) {
			return removed;
		}

		Session session = null;
		Transaction tx = null;
		try {
			session = GNodeHbUtil.newInstance().getSessionFactory()
					.openSession();
			tx = session.beginTransaction();

			Query query = session
					.createQuery("select gn from GNode gn "
							+ "where gn.originGNodeInfo.guid = ?");
			query.setParameter(0, gn.getGuid());
			List links = query.list();

			// first delete all the links.
			GNode originOne = null;
			for (int i = 0; i < links.size(); ++i) {
				GNode tmp = (GNode) links.get(i);
				if (tmp.isLink()) {
					session.delete(tmp);
					removed.add(tmp);
				} else {
					originOne = tmp;
				}
			}
			// then delete the origin one.
			session.delete(originOne);
			removed.add(originOne);

			// then delete the GNodeInfo.
			GNodeInfo gi = (GNodeInfo) session.load(GNodeInfo.class,
					gn.getGuid());
			session.delete(gi);

			tx.commit();

			return removed;
		} catch (Exception e) {
			log.error("transaction failed! " + e);
			try {
				log.warn("Trying to rollback transaction after exception");
				tx.rollback();
			} catch (Throwable rbEx) {
				log.error("Could not rollback transaction!", rbEx);
			}
			throw e;
		} finally {
			session.close();
		}
	}

	/**
	 * To get all qualified GNode.
	 * 
	 * @param searchCondition
	 *          search conditions in the form of Hibernate Query Language.
	 *          Some exampels are:<br>
	 *          Example 1:<br>
	 *          type=? and acl=? and version>? and attributes['keyword']=? and
	 *          attributes['serviceCategory']=? and attributes['attr\"2']=? <br>
	 *          Example 2:<br>
	 *          type=? and acl=? or version>?<br>
	 *          Caution!!! For those fields are ambitious, should and gn. or
	 *          gi. to indicate which Part of the GNode is needed. gn is the
	 *          part that all GNode will have, gi will be the part that link
	 *          to an origin GNode.<br>
	 *          Example 3: <br>
	 *          type=? and gi.guid=?
	 * @param values
	 *            the corresponding values according to the ? in
	 *            searchCondition. It's should be basic data type, such as
	 *            String, Integer and so on.
	 * @return all qualified GNode. If not found, the List size is 0.
	 * @throws Exception
	 *             network exceptions and others.
	 */
	public List search(String searchCondition, Object[] values)
			throws Exception {
		long begin = System.currentTimeMillis();
		Session session = null;
		Transaction tx = null;
		try {
			session = GNodeHbUtil.newInstance().getSessionFactory()
					.openSession();
			tx = session.beginTransaction();

			String condition = "";
			if (!StringUtil.isEmpty(searchCondition)) {
				condition += searchCondition;
			} else {
				values = new Object[] {};
			}

			if (!StringUtil.isEmpty(condition)) {
				condition = " and (" + condition + ")";
			}

			// deal with attribute search.
			// use replaceAll.
			// replace is not a valid method in jdk1.4. 2008.5.23.
			condition = condition.replaceAll("attributes\\['",
					"gi.attributes['");

			// here select both gn and gi can avoid load gi again for each gn!
			Query query = session
					.createQuery("select gn, gi from GNode gn, GNodeInfo gi "
							+ "where gn.originGNodeInfo.guid = gi.guid"
							+ condition);

			if (values.length > 0) {
				for (int i = 0; i < values.length; ++i) {
					query.setParameter(i, values[i]);
				}
			}

			List rst = query.list();

			tx.commit();

			// extract the GNode.
			List result = new ArrayList();
			for (int i = 0; i < rst.size(); ++i) {
				// FIXME
				GNode info = (GNode) ((Object[]) rst.get(i))[0];
				if (info != null) {
					info.setObj(DBConnUtil.undoEscape(info.getObj()));
				}
				result.add(info); // get the first one object.
			}

			long end = System.currentTimeMillis();
			log.info("search " + searchCondition + " count " + result.size()
					+ " time " + (end - begin));
			return result;
		} catch (Exception e) {
			log.error("transaction failed! " + e);
			try {
				log.warn("Trying to rollback transaction after exception");
				tx.rollback();
			} catch (Throwable rbEx) {
				log.error("Could not rollback transaction!", rbEx);
			}
			throw e;
		} finally {
			session.close();
		}
	}
}
