/*
 *  @(#)VirtualClusterManager.java  2010-5-27
 *
 *  Copyright (C) 2008-2011,
 *  LingCloud Team,
 *  Institute of Computing Technology,
 *  Chinese Academy of Sciences.
 *  P.O.Box 2704, 100190, Beijing, China.
 *
 *  http://lingcloud.org
 *  
 */

package org.lingcloud.molva.xmm.services;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.lingcloud.molva.ocl.asset.Asset;
import org.lingcloud.molva.ocl.asset.AssetManagerImpl;
import org.lingcloud.molva.ocl.lease.Lease;
import org.lingcloud.molva.ocl.lease.LeaseConstants;
import org.lingcloud.molva.ocl.lease.LeaseManagerImpl;
import org.lingcloud.molva.xmm.pojos.Nic;
import org.lingcloud.molva.xmm.pojos.NodeRequirement;
import org.lingcloud.molva.xmm.pojos.Partition;
import org.lingcloud.molva.xmm.pojos.PhysicalNode;
import org.lingcloud.molva.xmm.pojos.VirtualCluster;
import org.lingcloud.molva.xmm.pojos.VirtualNetwork;
import org.lingcloud.molva.xmm.pojos.VirtualNode;
import org.lingcloud.molva.xmm.util.XMMConstants;
import org.lingcloud.molva.xmm.util.XMMUtil;
import org.lingcloud.molva.xmm.vam.pojos.VirtualAppliance;
import org.lingcloud.molva.xmm.vam.util.VAMUtil;

/**
 * <strong>Purpose:</strong><br>
 * TODO.
 * 
 * @version 1.0.1 2009-9-29<br>
 * @author Xiaoyi Lu<br>
 */
public class VirtualClusterManager {
	// FIXME now we use lease life cycle state to describe virtual cluster
	// state. marked at 2010.07.19.

	/**
	 * the log object.
	 */
	private static Log log = LogFactory.getLog(VirtualClusterManager.class);

	private static VirtualClusterManager vcm = new VirtualClusterManager();

	private VirtualClusterManager() {

	}

	public static synchronized VirtualClusterManager getInstance() {
		return vcm;
	}

	/**
	 * The method to create virtual cluster for phsical node or virtual node.
	 * 
	 * @param parid
	 *            : partition id. required parameter.
	 * @param name
	 *            : virtual cluster name. required parameter.
	 * 
	 * @tenantId : the id of tenant.
	 * @param assetMatchMaker
	 *            : asset match maker of virtual cluster. required parameter.
	 * @param vnid
	 *            : virtual network id, it can be null or blank, then means the
	 *            virtual network generated by system automatically. if the vnid
	 *            is null or blank, the system will create a proper one
	 *            automatically. But if the nrmap contains the the key of
	 *            'ALL_NODE_SAME_REQUIREMENT_TAG', then the vnid is required.
	 *            conditional optional parameter.
	 * @param nrmap
	 *            : the key is the node's ip address, the value is its
	 *            requirement. when the key is 'ALL_NODE_SAME_REQUIREMENT_TAG',
	 *            it means all nodes have the same requirement. So this map has
	 *            one record at least. required parameter.
	 * @param effectiveTime
	 *            : the time of virtual cluster required to begin to run, but
	 *            not guarantee exactly. The gap between the expected time and
	 *            the real running time may gap in several seconds. optional
	 *            parameter.
	 * @param duration
	 *            : the expected running duration. its unit is ms. optional
	 *            parameter.
	 * @param expireTime
	 *            : the expected expire time, which means before this time, all
	 *            of the nodes in the virtual cluster should shutdown. it is
	 *            also hardly guaranteed. optional parameter.
	 * 
	 *            There are four kinds of leases.
	 * 
	 *            1> BestEffort Lease : "this.effectiveTime == null &&
	 *            this.expireTime == null && duration > 0"
	 * 
	 *            2> AR Lease :
	 *            "this.effectiveTime != null && this.expireTime != null"
	 * 
	 *            3> Deadline Stoping Lease : "this.effectiveTime == null &&
	 *            this.expireTime != null && duration > 0"
	 * 
	 *            4> Deadline Starting Lease : "this.effectiveTime != null &&
	 *            this.expireTime == null && duration > 0"
	 * 
	 * @param attributes
	 *            : other attributes to be extended. optional parameter.
	 * @param desc
	 *            : the description of virtual cluster. optional parameter.
	 * @return
	 * @throws Exception
	 */
	public synchronized VirtualCluster createVirtualCluster(String parid,
			String name, String assetMatchMaker, String tenantId, String vnid,
			HashMap<String, NodeRequirement> nrmap, Date effectiveTime,
			long duration, Date expireTime, HashMap<String, String> attributes,
			String desc) throws Exception {
		AssetManagerImpl ami = new AssetManagerImpl();
		@SuppressWarnings("unused")
		Partition par = new Partition(ami.view(parid));
//		if (par == null) {
//			throw new Exception("The Partition " + parid + " is not exist.");
//		}
		VirtualNetwork vn = null;
		if (vnid != null && !"".equals(vnid)) {
			// The vnid == null or blank means the virtual network should be
			// created automatically. If the vnid is not null or blank, then
			// means use the exist virtual network.
			Asset asset = ami.view(vnid);
			if (asset == null) {
				throw new Exception("The virtual network " + vnid
						+ " is not exist.");
			}
			vn = new VirtualNetwork(asset);

		}

		if (nrmap != null && nrmap.size() < 1) {
			throw new Exception(
					"The node requirement should have one record at least.");
		} else if (nrmap != null
				&& nrmap.containsKey(XMMConstants
						.ALL_NODE_SAME_REQUIREMENT_TAG)) {
			if (vnid == null || "".equals(vnid)) {
				throw new Exception("If you want all nodes have the "
						+ "same configuration, then you must identify "
						+ "which virtual network want to used, "
						+ "because I do not know how many nodes do you want.");
			}
		} else if (nrmap != null && nrmap.size() > 1) {
			// FIXME if nrmap has ALL_NODE_SAME_REQUIREMENT_TAG-value and
			// specific_ip-value pairs, then we must handle the specific case.

			if (nrmap
					.containsKey(XMMConstants.ALL_NODE_SAME_REQUIREMENT_TAG)) {
				throw new Exception(
						"If you indicate all node have the same requiremtns,"
								+ " please do not set other requirements.");
			}

			// As above, we must handle the specific requirement.

			// Notice me, in order to reduce the complexity of codes, we left
			// above problems to the client. e.g. users can use default value to
			// construct nrmap.
			if (vn != null) {
				if (vn.getNetworkSize() != nrmap.size()) {
					throw new Exception("If you choose the virtual network, "
							+ "then your requirements should have "
							+ "the same size with virtual network.");
				} else {
					List<Nic> pips = vn.getPrivateIpNics();
					for (int i = 0; i < pips.size(); i++) {
						String ip = pips.get(i).getIp();
						NodeRequirement nr = nrmap.get(ip);
						if (nr == null) {
							throw new Exception("The node " + ip
									+ " does not have the "
									+ "requirement description.");
						}
					}
				}
			}
		}

		// check the nrmap fields.
		Iterator<String> it = nrmap.keySet().iterator();
		while (it.hasNext()) {
			String key = (String) it.next();
			// A bug due to fail-fast iterator. When iterator all elements in
			// the map, we can't remove any element in the map.
			NodeRequirement nr = nrmap.get(key);
			// make sure all of the nodes have the same partition id.
			nr.setPartitionId(parid);
			nrmap.put(key, nr);
		}

		VirtualCluster vc = new VirtualCluster();
		vc.setPartitionId(parid);
		vc.setName(name);
		vc.setAssetMatchMaker(assetMatchMaker);
		vc.setVirtualNetworkId(vnid);
		vc.setTenantId(tenantId);
		vc.setNodeRequirements(nrmap);
		vc.setEffectiveTime(effectiveTime);
		vc.setDuration(duration);
		vc.setExpireTime(expireTime);
		vc.setDescription(desc);

		if (attributes != null && !attributes.isEmpty()) {
			vc.getAdditionalTerms().putAll((attributes));
		}

		LeaseManagerImpl lmi = new LeaseManagerImpl();
		VirtualCluster newvc = new VirtualCluster(lmi.add(vc));
		log.info("Create a virtual cluster with name " + newvc.getName()
				+ " OK, by the tenant " + tenantId + ".");

		return newvc;

	}

	// FIXME, in opennebula1.21 test, i found shutdown = destroy, stop and
	// resume is a pair of function, like start and stop, and i found only the
	// transfer manager is tm_nfs, the stop function is right.

	// FIXME start and stop virtual cluster is also responsed with the running
	// status of lease.
	public synchronized void startVirtualCluster(VirtualCluster vcluster)
			throws Exception {
		if (vcluster == null) {
			throw new Exception("The input virtual cluster is a null object!");
		}
		if (vcluster.getLifecycleState() != LeaseConstants.
				LeaseLifeCycleState.EFFECTIVE) {
			return;
		}
		AssetManagerImpl ami = new AssetManagerImpl();
		HashMap<String, String> itmap = vcluster.getAssetIdAndTypeMap();
		if (itmap != null && !itmap.isEmpty()) {
			Iterator<String> it = itmap.keySet().iterator();
			while (it.hasNext()) {
				String assetid = it.next();
				String value = itmap.get(assetid);
				if (value.equals(VirtualNode.class.getName())) {
					Asset asset = ami.view(assetid);
					if (asset == null) {
						continue;
					}
					VirtualNode vn = new VirtualNode(asset);
					if (XMMConstants.MachineRunningState.STOP.toString()
							.equals(vn.getRunningStatus())) {
						ami.control(asset, "start", new Object[] { vn });
					}
				} else if (value.equals(PhysicalNode.class.getName())) {
					Asset asset = ami.view(assetid);
					if (asset == null) {
						continue;
					}
					PhysicalNode pn = new PhysicalNode(asset);
					if (XMMConstants.MachineRunningState.STOP.toString()
							.equals(pn.getRunningStatus())) {
						ami.control(asset, "start", new Object[] { pn });
					} else {
						throw new Exception();
					}
				} else {
					continue;
				}
			}
		}
		return;
	}

	public synchronized void stopVirtualCluster(VirtualCluster vcluster)
			throws Exception {
		if (vcluster == null) {
			throw new Exception("The input virtual cluster is null.");
		}
		if (vcluster.getLifecycleState() != LeaseConstants.
				LeaseLifeCycleState.EFFECTIVE) {
			return;
		}
		AssetManagerImpl ami = new AssetManagerImpl();
		HashMap<String, String> itmap = vcluster.getAssetIdAndTypeMap();
		if (itmap != null && !itmap.isEmpty()) {
			Iterator<String> it = itmap.keySet().iterator();
			while (it.hasNext()) {
				String assetid = it.next();
				String value = itmap.get(assetid);
				if (value.equals(VirtualNode.class.getName())) {
					Asset asset = ami.view(assetid);
					if (asset == null) {
						continue;
					}
					VirtualNode vn = new VirtualNode(asset);
					if (XMMConstants.MachineRunningState.RUNNING.toString()
							.equals(vn.getRunningStatus())) {
						ami.control(asset, "stop", new Object[] { vn });
					}
				} else if (value.equals(PhysicalNode.class.getName())) {
					Asset asset = ami.view(assetid);
					if (asset == null) {
						continue;
					}
					PhysicalNode pn = new PhysicalNode(asset);
					if (XMMConstants.MachineRunningState.RUNNING.toString()
							.equals(pn.getRunningStatus())) {
						ami.control(asset, "stop", new Object[] { pn });
					}
				} else {
					continue;
				}
			}
		}
		return;
	}

	public synchronized void destroyVirtualCluster(String vcid)
			throws Exception {
		LeaseManagerImpl lmi = new LeaseManagerImpl();
		Lease lease = lmi.view(vcid);
		if (lease == null) {
			return;
		}
		VirtualCluster vc = new VirtualCluster(lease);
//		if (vc == null) {
//			throw new Exception("The VirtualCluster " + vcid 
//					+ " is not exist.");
//		}
		// terminate only control all assets to stop running, not remove them.
		lmi.terminate(vcid);

		// before remove virtual cluster, we should do some clear operation to
		// different kinds of assets.
		HashMap<String, String> assetIdType = vc.getAssetIdAndTypeMap();
		VirtualNetwork vn = null;
		if (assetIdType == null || assetIdType.isEmpty()) {
			log.warn("Some errors occurred before destroy "
					+ "the virtual cluster (" + vc.getName()
					+ "), due to its assetIdAndType map is null or empty.");
		} else {
			Iterator<String> it = assetIdType.keySet().iterator();
			while (it.hasNext()) {
				String id = (String) it.next();
				String type = assetIdType.get(id);
				if (type == null || "".equals(type)) {
					log.warn("The type of asset with id " + id
							+ " in the assetIdAndTypeMap of virtual cluster "
							+ vc.getName() + " is blank or null.");
					continue;
				}
				if (type.equals(VirtualNode.class.getName())) {
					// virtual machine meta info will be removed.
					try {
						PartitionManager.getInstance().removeVirtualNode(id,
								false);
					} catch (Throwable t) {
						log.fatal("The virtual node with id '(" + id
								+ ")' of the virtual cluster ('" + vc.getGuid()
								+ "') is deleted failed, due to "
								+ t.toString() + ".");
					}
					continue;
				} else if (type.equals(PhysicalNode.class.getName())) {
					// no need to do anything.
					continue;
				} else if (type.equals(VirtualNetwork.class.getName())) {
					try {
						vn = VirtualNetworkManager.getInstance().view(id);
						if (vn == null) {
							log.warn("The virtual network of virtual cluster ("
									+ vc.getName() + ", " + vc.getGuid()
									+ ") is not exist.");
							continue;
						}
					} catch (Throwable t) {
						// ignore error.
						log.fatal("The virtual network with id '(" + id
								+ ")' of the virtual cluster ('" + vc.getGuid()
								+ "') is deleted failed, due to "
								+ t.toString() + ".");
					}
					continue;
				} else if (type.equals(VirtualAppliance.class.getName())) {
					try {
						VAMUtil.getVAManager().removeAppliance(id);
					} catch (Throwable t) {
						log.fatal("The virtual appliance with id '(" + id
								+ ")' of the virtual cluster ('" + vc.getGuid()
								+ "') is deleted failed, due to "
								+ t.toString() + ".");
					}
					continue;
				} else {
					log.warn("The asset with id " + id
							+ " in the virtual cluster " + vc.getName()
							+ " does not have a valid type.");
					continue;
				}
			}
		}
		lmi.remove(vcid);
		// the virtual network should be deleted after the cluster and if it is
		// created by manual, then it only can be deleted by manual also.
		if (vn != null && vn.isAutoCreate()) {
			VirtualNetworkManager.getInstance().destroyVirtualNetwork(
					vn.getGuid());
		}
	}

	public synchronized VirtualCluster refreshVirtualCluster(String vcid)
			throws Exception {
		return null;
	}

	public VirtualCluster updateVirtualClusterInfo(String guid,
			VirtualCluster vc) throws Exception {
		LeaseManagerImpl lmi = new LeaseManagerImpl();
		Lease upLease = lmi.update(guid, vc);
		if (upLease == null) {
			return null;
		}
		return new VirtualCluster(upLease);
	}

	public VirtualCluster view(String vcid) throws Exception {
		if (vcid == null || "".equals(vcid)) {
			return null;
		}
		LeaseManagerImpl lmi = new LeaseManagerImpl();
		Lease lease = lmi.view(vcid);
		if (lease == null) {
			return null;
		}
		return new VirtualCluster(lease);
	}

	public List<VirtualCluster> searchVirtualCluster(String[] searchConditions,
			String[] operators, Object[] values) throws Exception {
		List<String> scon = new ArrayList<String>();
		List<String> opers = new ArrayList<String>();
		List<Object> vals = new ArrayList<Object>();

		if (searchConditions != null) {
			for (int i = 0; i < searchConditions.length; i++) {
				if (searchConditions[i].equals("type")) {
					continue;
				}
				scon.add(searchConditions[i]);
				opers.add(operators[i]);
				vals.add(values[i]);
			}
		}

		scon.add("type");
		opers.add("=");
		vals.add(XMMConstants.VIRTUAL_CLUSTER_TYPE);

		LeaseManagerImpl lmi = new LeaseManagerImpl();
		List<Lease> lelist = lmi.search(scon.toArray(new String[scon.size()]),
				opers.toArray(new String[scon.size()]), vals.toArray());
		if (lelist == null || lelist.isEmpty()) {
			return null;
		}
		List<VirtualCluster> vclist = new ArrayList<VirtualCluster>();
		for (int k = 0; k < lelist.size(); k++) {
			VirtualCluster vc = new VirtualCluster(lelist.get(k));
			vclist.add(vc);
		}
		return vclist;
	}

	@SuppressWarnings("unused")
	private boolean checkValidity(Lease newLease, Lease lease) {
		return (newLease.getAcl() == null || newLease.getAcl().equals(
				lease.getAcl()))
				&& (newLease.getAddTime() == null || newLease.getAddTime()
						.equals(lease.getAddTime()))
				&& (newLease.getGroupId() == null || newLease.getGroupId()
						.equals(lease.getGroupId()))
				&& (newLease.getGuid() == null || newLease.getGuid().equals(
						lease.getGuid()))
				&& (newLease.getAssetMatchMaker() == null || newLease
						.getAssetMatchMaker()
						.equals(lease.getAssetMatchMaker()))
				&& (newLease.getName() == null || newLease.getName().equals(
						lease.getName()))
				&& (newLease.getTenantId() == null || newLease.getTenantId()
						.equals(lease.getTenantId()));
	}

	@SuppressWarnings("unused")
	private void doMonitorConfig(VirtualNetwork vn, String method)
			throws Exception {
		String command = XMMUtil.getMonitorConfigCommandInCfgFile() + " "
				+ method + " " + vn.getHeadNodeIp() + " ";
		List<Nic> leaselist = vn.getPrivateIpNics();
		StringBuilder slaveips = new StringBuilder();
		for (int i = 0; i < leaselist.size(); i++) {
			String lip = leaselist.get(i).getIp();
			if (lip != null && !lip.equals(vn.getHeadNodeIp())) {
				slaveips.append(lip);
				if (i == (leaselist.size() - 1)) {
					break;
				}
				slaveips.append(",");
			}
		}
		command = command + slaveips.toString();
		log.info("Do monitor config by command : '" + command + "'.");
		XMMUtil.runCommand(command);
	}

}
