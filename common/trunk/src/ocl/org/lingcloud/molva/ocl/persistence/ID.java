/*
 *  @(#)ID.java  2007-8-6
 *
 *  Copyright (C) 2008-2011,
 *  LingCloud Team,
 *  Institute of Computing Technology,
 *  Chinese Academy of Sciences.
 *  P.O.Box 2704, 100190, Beijing, China.
 *
 *  http://lingcloud.org
 *  
 */

package org.lingcloud.molva.ocl.persistence;

import java.io.Serializable;

/**
 * 
 * <strong>Purpose:</strong><br>
 * The global unique identifier for sites and user-defined objects. It's
 * generated by naming system, or provided by user. Once created, an ID instance
 * is unmodifiable.
 * 
 * IDs of same length can be compared as this class implements
 * java.lang.Comparable. IDs of different length cannot be compared.
 * 
 * @version 1.0.1 2007-8-6<br>
 * @author zouyongqiang<br>
 * 
 */
public final class ID implements Comparable<ID>, Serializable {
	/*
	 * This file is based on OpenChord project's class ID written by Sven
	 * Kaffille, Karsten Loesing.
	 */

	/**
	 * Default length of ID in bits.
	 */
	public static final int DEFAULT_ID_LENGTH = 160;

	/**
	 * bit number of a byte.
	 */
	private static final int BITS_PER_BYTE = 8;

	/**
	 * Max byte value.
	 */
	private static final int MAX_BYTE = 0xff;

	/**
	 * for serialize.
	 */
	private static final long serialVersionUID = -994979223403726393L;

	/**
	 * Number of bytes of an id returned as String when {@link #toString()} is
	 * invoked.
	 */
	private static int numberOfDisplayedBytes = DEFAULT_ID_LENGTH
			/ BITS_PER_BYTE;

	/**
	 * The bytes representing the id.
	 */
	private final byte[] id;

	/**
	 * Creates a new ID consisting of the given byte[] array. The ID is assumed
	 * to have (ID.length * 8) bits. It must have leading zeros if its value has
	 * fewer digits than its maximum length.
	 * 
	 * @param id1
	 *            Byte array containing the ID.
	 */
	public ID(byte[] id1) {
		if (id1 == null || numberOfDisplayedBytes != id1.length) {
			throw new IllegalArgumentException(
					"Invalid ID due to wrong ID lenght. It should be "
							+ numberOfDisplayedBytes + " bytes.");
		}

		this.id = new byte[id1.length];
		System.arraycopy(id1, 0, this.id, 0, id1.length);
	}

	/**
	 * Returns a new ID instance with the value given as a String.
	 * 
	 * @param hexString
	 *            ID string.
	 * @return generated ID.
	 */
	public static ID getIDfromHexString(String hexString) {
		int size = numberOfDisplayedBytes;
		if (hexString == null || hexString.length() < size * 2) {
			throw new IllegalArgumentException("Given ID is too short: "
					+ hexString);
		}

		byte[] id = new byte[size];
		for (int i = 0, idx = (size - 1) * 2; i < size; i++, idx -= 2) {
			int b = Integer.parseInt(hexString.substring(idx, idx + 2),
					2 * BITS_PER_BYTE);
			id[size - 1 - i] = (byte) (b & MAX_BYTE);
		}

		return new ID(id);
	}

	/**
	 * Representation of this as a String.
	 */
	private transient String stringRepresentation = null;

	/**
	 * Returns a string of the decimal representation of this ID, including
	 * leading zeros.
	 * 
	 * @return Hex string of ID
	 */
	public String toString() {
		if (this.stringRepresentation == null) {
			this.stringRepresentation = this
					.toHexString(ID.numberOfDisplayedBytes);
		}
		return this.stringRepresentation;
	}

	/**
	 * Returns a string of the hexadecimal representation of the first
	 * <code>n</code> bytes of this ID, including leading zeros.
	 * 
	 * @param numberOfBytes
	 *            the number of bytes want to display.
	 * 
	 * @return Hex string of ID
	 */
	private String toHexString(int numberOfBytes) {

		// number of displayed bytes must be in interval [1, this.id.length]
		int displayBytes = Math.max(1, Math.min(numberOfBytes, this.id.length));

		String result = "";
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i < displayBytes; i++) {

			String block = Integer.toHexString(this.id[i] & MAX_BYTE)
					.toUpperCase();

			// add leading zero to block, if necessary
			if (block.length() < 2) {
				block = "0" + block;
			}

			// don't split the bytes.
			buf.append(block);
		}
		result = buf.toString();
		return result;
	}

	/**
	 * Returns a string of the hexadecimal representation of this ID, including
	 * leading zeros.
	 * 
	 * @return Hex string of ID
	 */
	public String toHexString() {
		return this.toHexString(this.id.length);
	}

	/**
	 * Returns a string of the decimal representation of the first
	 * <code>n</code> bytes of this ID, including leading zeros.
	 * 
	 * @param numberOfBytes
	 *            the number of bytes want to display.
	 * 
	 * @return Hex string of ID
	 */
	private String toDecimalString(int numberOfBytes) {

		// number of displayed bytes must be in interval [1, this.id.length]
		int displayBytes = Math.max(1, Math.min(numberOfBytes, this.id.length));

		String result = "";
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i < displayBytes; i++) {

			String block = Integer.toString(this.id[i] & MAX_BYTE);

			buf.append(block + " ");
		}
		result = buf.toString();
		return result;
	}

	/**
	 * Returns a string of the decimal representation of this ID, including
	 * leading zeros.
	 * 
	 * @return Decimal string of ID
	 */
	public String toDecimalString() {
		return this.toDecimalString(this.id.length);
	}

	/**
	 * Returns a string of the binary representation of the first <code>n</code>
	 * bytes of this ID, including leading zeros.
	 * 
	 * @param numberOfBytes
	 *            the number of bytes want to display.
	 * 
	 * @return Hex string of ID
	 */
	private String toBinaryString(int numberOfBytes) {

		// number of displayed bytes must be in interval [1, this.id.length]
		int displayBytes = Math.max(1, Math.min(numberOfBytes, this.id.length));

		String result = "";
		StringBuffer buf = new StringBuffer();
		for (int i = 0; i < displayBytes; i++) {

			String block = Integer.toBinaryString(this.id[i] & MAX_BYTE);

			// add leading zero to block, if necessary
			while (block.length() < BITS_PER_BYTE) {
				block = "0" + block;
			}

			buf.append(block + " ");
		}
		result = buf.toString();
		return result;
	}

	/**
	 * Returns a string of the binary representation of this ID, including
	 * leading zeros.
	 * 
	 * @return Binary string of ID
	 */
	public String toBinaryString() {
		return this.toBinaryString(this.id.length);
	}

	/**
	 * Returns length of this ID measured in bits. ID length is determined by
	 * the length of the stored byte[] array, i.e. leading zeros have to be
	 * stored in the array.
	 * 
	 * @return Length of this ID measured in bits.
	 */
	public int getLength() {
		return this.id.length * BITS_PER_BYTE;
	}

	/**
	 * Calculates the ID which is 2^powerOfTwo bits greater than the current ID
	 * modulo the maximum ID and returns it.
	 * 
	 * @param powerOfTwo
	 *            Power of two which is added to the current ID. Must be a value
	 *            of the interval [0, length-1], including both extremes.
	 * @return ID which is 2^powerOfTwo bits greater than the current ID modulo
	 *         the maximum ID.
	 */
	public ID addPowerOfTwo(int powerOfTwo) {

		if (powerOfTwo < 0 || powerOfTwo >= (id.length * BITS_PER_BYTE)) {
			throw new IllegalArgumentException(
					"The power of two is out of range! "
							+ "It must be in the interval [0, length-1]");
		}

		// copy ID
		byte[] copy = new byte[this.id.length];
		System.arraycopy(this.id, 0, copy, 0, this.id.length);

		// determine index of byte and the value to be added
		int indexOfByte = this.id.length - 1 - (powerOfTwo / BITS_PER_BYTE);
		final int pow0 = 1, pow1 = 2, pow2 = 4, pow3 = 8;
		final int pow4 = 16, pow5 = 32, pow6 = 64, pow7 = -128;
		byte[] toAdd = { pow0, pow1, pow2, pow3, pow4, pow5, pow6, pow7 };
		byte valueToAdd = toAdd[powerOfTwo % BITS_PER_BYTE];
		byte oldValue;

		do {
			// add value
			oldValue = copy[indexOfByte];
			copy[indexOfByte] += valueToAdd;

			// reset value to 1 for possible overflow situation
			valueToAdd = 1;
		}
		// check for overflow - occurs if old value had a leading one, i.e. it
		// was negative, and new value has a leading zero, i.e. it is zero or
		// positive; indexOfByte >= 0 prevents running out of the array to the
		// left in case of going over the maximum of the ID space
		while (oldValue < 0 && copy[indexOfByte] >= 0 && indexOfByte-- > 0);

		return new ID(copy);
	}

	/**
	 * Checks the given object for equality with this {@link ID}.
	 * 
	 * @param equalsTo
	 *            Object to check equality with this {@link ID}.
	 * @return return true if is equal.
	 */
	public boolean equals(Object equalsTo) {
		// check if given object has correct type
		if (equalsTo == null || !(equalsTo instanceof ID)) {
			return false;
		}

		// check if both byte arrays are equal by using the compareTo method
		return (this.compareTo((ID) equalsTo) == 0);

	}

	/**
	 * @see java.lang.Object#hashCode()
	 * @return the hash code of the ID.
	 */
	public int hashCode() {
		final int primary1 = 19, primary2 = 13;

		int result = primary1;
		for (int i = 0; i < this.id.length; i++) {
			result = primary2 * result + this.id[i];
		}
		return result;
	}

	/**
	 * Checks if this ID is in the interval determined by the two given IDs.
	 * Neither of the boundary IDs is included in the interval. If both IDs
	 * match, the interval is assumed to span the whole ID ring.
	 * 
	 * @param fromID
	 *            Lower bound of interval.
	 * @param toID
	 *            Upper bound of interval.
	 * @return If this key is included in the given interval.
	 */
	public boolean isInInterval(ID fromID, ID toID) {

		// both interval bounds are equal -> calculate out of equals
		if (fromID.equals(toID)) {
			// every ID is contained in the interval except of the two bounds
			return (!this.equals(fromID));
		}

		// interval does not cross zero -> compare with both bounds
		if (fromID.compareTo(toID) < 0) {
			return (this.compareTo(fromID) > 0 && this.compareTo(toID) < 0);
		}

		// interval crosses zero -> split interval at zero
		// calculate min and max IDs
		byte[] minIDBytes = new byte[this.id.length];
		ID minID = new ID(minIDBytes);
		byte[] maxIDBytes = new byte[this.id.length];
		for (int i = 0; i < maxIDBytes.length; i++) {
			maxIDBytes[i] = -1;
		}
		ID maxID = new ID(maxIDBytes);
		// check both splitted intervals
		// first interval: (fromID, maxID] || second interval: [minID, toID)
		return ((!fromID.equals(maxID) && this.compareTo(fromID) > 0 && this
				.compareTo(maxID) <= 0) || (!minID.equals(toID)
				&& this.compareTo(minID) >= 0 && this.compareTo(toID) < 0));
	}

	/**
	 * Compare current ID with the given object. If either the object is not a
	 * ID or both IDs' lengths do not match, a ClassCastException is thrown.
	 * Otherwise both IDs are compared byte by byte.
	 * 
	 * @param otherObj
	 *            the other object to be compared.
	 * @return -1, 0, or 1, if this ID is smaller, same size, or greater than
	 *         the given object, respectively.
	 */
	public int compareTo(ID otherObj) {
		ID otherKey = otherObj;
		if (this.getLength() != otherKey.getLength()) {
			throw new ClassCastException(
					"Only ID objects with same length can be "
							+ "compared! This ID is " + this.id.length
							+ " bits long while the other ID is "
							+ otherKey.getLength() + " bits long.");
		}

		// compare value byte by byte
		byte[] otherBytes = new byte[this.id.length];
		System.arraycopy(otherKey.id, 0, otherBytes, 0, this.id.length);

		final int midN = 128;
		for (int i = 0; i < this.id.length; i++) {
			if ((byte) (id[i] - midN) < (byte) (otherBytes[i] - midN)) {
				return -1; // this ID is smaller
			} else if ((byte) (id[i] - midN) > (byte) (otherBytes[i] - midN)) {
				return 1; // this ID is greater
			}
		}
		return 0;
	}
}
